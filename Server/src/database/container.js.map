{"version":3,"sources":["database/container.ts"],"names":[],"mappings":";;;;;AAAA,oDAAoF;AACpF,2CAAiD;AACjD,mCAAwC;AACxC,6CAAuC;AAEvC,0CAAoC;AAEvB,QAAA,mBAAmB,GAAG,IAAI,CAAC,KAAM,SAAQ,sBAA4B;IAA1C;;QAC3B,SAAI,GAAG,0BAAc,CAAA;QAErB,WAAM,GAAG,2BAAe,CAAA;IAuCrC,CAAC;IArCG,OAAO,CAAC,GAAQ;QACZ,MAAM,SAAS,GAAiB;YAC5B,GAAG,EAAE,GAAG,CAAC,EAAE;YACX,IAAI,EAAE,GAAG,CAAC,IAAI,IAAI,EAAE;YACpB,IAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC;SAC/B,CAAA;QAED,IAAI,GAAG,CAAC,WAAW,EAAE;YACjB,SAAS,CAAC,WAAW,GAAG,GAAG,CAAC,WAAW,CAAA;SAC1C;QAED,IAAI,GAAG,CAAC,MAAM,EAAE;YACZ,SAAS,CAAC,QAAQ,GAAG,GAAG,CAAC,MAAM,CAAA;SAClC;QAED,IAAI,GAAG,CAAC,cAAc,EAAE;YACpB,SAAS,CAAC,cAAc,GAAG,GAAG,CAAC,cAAc,CAAA;SAChD;QAED,MAAM,MAAM,GAAG,qBAAQ,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,CAAA;QAE/C,IAAI,MAAM,EAAE;YACR,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAA;SAC1C;QAED,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAA;IACjC,CAAC;IAES,KAAK,CAAC,SAAS,CAAC,EAAU;QAChC,OAAO,+BAAmB,CAAC,KAAK,CAAC,aAAa,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAA;IACjE,CAAC;IAES,KAAK,CAAC,UAAU,CAAC,EAAU;QACjC,MAAM,EAAE,GAAG,MAAM,IAAI,CAAC,aAAa,EAAE,CAAA;QAErC,MAAM,EAAE,CAAC,UAAU,CAAC,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,QAAQ,IAAI,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE,CAAC,CAAA;IACnG,CAAC;CACJ,CAAC,EAAE,CAAA","file":"container.js","sourcesContent":["import { collectionName, ContainerSchema, IDbContainer } from './entities/container'\nimport { recordingCollection } from './recording'\nimport { CollectionBase } from './utils'\nimport { validate } from './validation'\n\nexport * from './entities/container'\n\nexport const containerCollection = new (class extends CollectionBase<IDbContainer> {\n    readonly name = collectionName\n\n    readonly schema = ContainerSchema\n\n    fromSql(sql: any): void {\n        const container: IDbContainer = {\n            _id: sql.Id,\n            name: sql.Name || '',\n            type: parseInt(sql.Type, 10),\n        }\n\n        if (sql.Description) {\n            container.description = sql.Description\n        }\n\n        if (sql.Parent) {\n            container.parentId = sql.Parent\n        }\n\n        if (sql.ParentLocation) {\n            container.parentLocation = sql.ParentLocation\n        }\n\n        const errors = validate(container, this.schema)\n\n        if (errors) {\n            throw new Error(JSON.stringify(errors))\n        }\n\n        this.cacheMigrated(container)\n    }\n\n    protected async canDelete(id: string): Promise<string> {\n        return recordingCollection.inUse('containerId', id, 'Ablage')\n    }\n\n    protected async postDelete(id: string): Promise<void> {\n        const me = await this.getCollection()\n\n        await me.updateMany({ parentId: typeof id === 'string' && id }, { $unset: { parentId: null } })\n    }\n})()\n"],"sourceRoot":"/home/jochenmanns/Software/git/MovieDBNode/Server/src"}