{"version":3,"sources":["database/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["import * as debug from 'debug'\nimport { Collection, Db, FilterQuery, MongoClient } from 'mongodb'\n\nimport { IValidatableSchema, IValidationError } from 'movie-db-api'\n\nimport { validate } from './validation'\n\nimport { getError } from '../utils'\n\nconst databaseError = debug('database')\n\nlet loader: Promise<MongoClient>\n\nfunction sleep(ms: number): Promise<void> {\n    return new Promise<void>(success => setTimeout(success, ms))\n}\n\nexport async function dbConnect(): Promise<Db> {\n    for (; ; await sleep(5000)) {\n        if (!loader) {\n            loader = MongoClient.connect(process.env.DATABASE, {\n                autoReconnect: true,\n                promiseLibrary: Promise,\n                reconnectTries: Number.MAX_VALUE,\n                useNewUrlParser: true,\n            })\n        }\n\n        try {\n            const client = await loader\n\n            return client.db()\n        } catch (e) {\n            databaseError('unable to connect to database: %s', getError(e))\n\n            loader = null\n        }\n    }\n}\n\nexport abstract class CollectionBase<TType extends { _id: string }> {\n    abstract readonly name: string\n\n    abstract readonly schema: IValidatableSchema\n\n    readonly migrationMap: { [id: string]: TType } = {}\n\n    protected cacheMigrated(item: TType): void {\n        if (this.migrationMap[item._id]) {\n            throw new Error(`duplicated identifier '${item._id}`)\n        }\n\n        this.migrationMap[item._id] = item\n    }\n\n    async migrate(): Promise<void> {\n        for (let item of Object.values(this.migrationMap)) {\n            await this.insertOne(item)\n        }\n    }\n\n    async getCollection(): Promise<Collection<TType>> {\n        const db = await dbConnect()\n\n        return db.collection(this.name)\n    }\n\n    async insertOne(container: TType): Promise<IValidationError[]> {\n        try {\n            const me = await this.getCollection()\n\n            await me.insertOne(container)\n\n            return undefined\n        } catch (error) {\n            if (error.code !== 121) {\n                databaseError('error during insert: %s', getError(error))\n\n                throw error\n            }\n\n            try {\n                return (\n                    validate(container, this.schema) || [\n                        { constraint: 'database', message: getError(error), property: '*' },\n                    ]\n                )\n            } catch (e) {\n                databaseError('error during insert validation: %s', getError(e))\n\n                throw error\n            }\n        }\n    }\n\n    async findOneAndReplace(container: TType): Promise<IValidationError[]> {\n        try {\n            const me = await this.getCollection()\n            const updated = await me.findOneAndReplace({ _id: container._id }, container)\n\n            if (!updated) {\n                return [{ constraint: 'database', message: 'Nicht gefunden', property: '_id' }]\n            }\n\n            return undefined\n        } catch (error) {\n            if (error.code !== 121) {\n                databaseError('error during update: %s', getError(error))\n\n                throw error\n            }\n\n            try {\n                return (\n                    validate(container, this.schema) || [\n                        { constraint: 'database', message: getError(error), property: '*' },\n                    ]\n                )\n            } catch (e) {\n                databaseError('error during update validation: %s', getError(e))\n\n                throw error\n            }\n        }\n    }\n\n    async find(filter?: FilterQuery<TType>, sort?: object, project?: object): Promise<TType[]> {\n        const me = await this.getCollection()\n\n        let query = me.find(filter)\n\n        if (sort) {\n            query = query.sort(sort)\n        }\n\n        if (project) {\n            query = query.project(project)\n        }\n\n        return query.toArray()\n    }\n\n    async findOne(id: string): Promise<TType> {\n        const me = await this.getCollection()\n\n        return me.findOne({ _id: id.toString() })\n    }\n}\n"],"sourceRoot":"/home/jochenmanns/Software/git/MovieDBNode/Server/src"}