{"version":3,"sources":["database/recording.ts"],"names":[],"mappings":"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","file":"recording.js","sourcesContent":["import { FilterQuery } from 'mongodb'\n\nimport { IQueryCountInfo, IRecordingQueryRequest, IRecordingQueryResponse } from 'movie-db-api'\n\nimport { collectionName, IDbRecording, RecordingSchema } from './entities/recording'\nimport { CollectionBase } from './utils'\nimport { validate } from './validation'\n\nexport * from './entities/recording'\n\nconst dateReg = /^CAST\\(N'([^\\.]+)(\\.\\d+)?' AS DateTime\\)$/\n\ninterface IAggregateCount {\n    total: number\n}\n\ninterface IAggregationResult {\n    count: IAggregateCount[]\n    languages: IQueryCountInfo[]\n    genres: IQueryCountInfo[]\n    view: IDbRecording[]\n}\n\nconst escapeReg = /[.*+?^${}()|[\\]\\\\]/g\n\nexport const recordingCollection = new (class extends CollectionBase<IDbRecording> {\n    readonly name = collectionName\n\n    readonly schema = RecordingSchema\n\n    fromSql(sql: any): void {\n        const date = dateReg.exec(sql.Created)\n\n        const recording: IDbRecording = {\n            _id: sql.Id,\n            created: (date && `${date[1]}Z`) || sql.Created,\n            genres: [],\n            languages: [],\n            links: [],\n            media: sql.Media,\n            name: sql.Name,\n        }\n\n        if (sql.Description) {\n            recording.description = sql.Description\n        }\n\n        if (sql.RentTo) {\n            recording.rentTo = sql.RentTo\n        }\n\n        if (sql.Series) {\n            recording.series = sql.Series\n        }\n\n        const errors = validate(recording, this.schema)\n\n        if (errors) {\n            throw new Error(JSON.stringify(errors))\n        }\n\n        this.cacheMigrated(recording)\n    }\n\n    async query(req: IRecordingQueryRequest): Promise<IRecordingQueryResponse> {\n        const filter: FilterQuery<IDbRecording> = { $or: [] }\n\n        if (req.name) {\n            filter.$or.push({ name: { $regex: req.name.toString().replace(escapeReg, '\\\\$&'), $options: 'i' } })\n        }\n\n        if (req.nameSeries && req.nameSeries.length > 0) {\n            filter.$or.push({ series: { $in: req.nameSeries.map(s => s.toString()) } })\n        }\n\n        if (filter.$or.length < 1) {\n            delete filter.$or\n        }\n\n        if (req.language) {\n            filter.languages = req.language.toString()\n        }\n\n        if (req.genres && req.genres.length > 0) {\n            filter.genres = { $all: req.genres.map(s => s.toString()) }\n        }\n\n        if (req.series && req.series.length > 0) {\n            filter.series = { $in: req.series.map(s => s.toString()) }\n        }\n\n        if (typeof req.rent === 'boolean') {\n            filter.rentTo = { $exists: req.rent }\n        }\n\n        const query = [\n            { $match: filter },\n            {\n                $facet: {\n                    count: [{ $count: 'total' }],\n                    languages: [{ $unwind: '$languages' }, { $group: { _id: '$languages', count: { $sum: 1 } } }],\n                    genres: [{ $unwind: '$genres' }, { $group: { _id: '$genres', count: { $sum: 1 } } }],\n                    view: [\n                        { $sort: { [req.sort.toString()]: req.sortOrder === 'ascending' ? +1 : -1 } },\n                        { $skip: 1 * req.firstPage * req.pageSize },\n                        { $limit: 1 * req.pageSize },\n                    ],\n                },\n            },\n        ]\n\n        const db = await this.getCollection()\n        const result = await db.aggregate<IAggregationResult>(query).toArray()\n\n        const firstRes = result && result[0]\n        const countRes = firstRes && firstRes.count && firstRes.count[0]\n\n        return {\n            genres: (firstRes && firstRes.genres) || [],\n            languages: (firstRes && firstRes.languages) || [],\n            total: (countRes && countRes.total) || 0,\n            view: (firstRes && firstRes.view) || [],\n        }\n    }\n})()\n"],"sourceRoot":"/home/jochenmanns/Software/git/MovieDBNode/Server/src"}