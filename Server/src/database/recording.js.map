{"version":3,"sources":["database/recording.ts"],"names":[],"mappings":"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","file":"recording.js","sourcesContent":["import * as debug from 'debug'\nimport { CollationDocument, FilterQuery } from 'mongodb'\n\nimport * as api from 'movie-db-api'\n\nimport { collectionName, IDbRecording, RecordingSchema } from './entities/recording'\nimport { CollectionBase } from './utils'\nimport { validate } from './validation'\n\nexport * from './entities/recording'\n\nconst databaseTrace = debug('database:trace')\nconst dateReg = /^CAST\\(N'([^\\.]+)(\\.\\d+)?' AS DateTime\\)$/\n\ninterface IAggregateCount {\n    total: number\n}\n\ninterface IAggregationResult {\n    count: IAggregateCount[]\n    genres: api.IQueryCountInfo[]\n    view: api.IRecordingInfo[]\n}\n\nconst escapeReg = /[.*+?^${}()|[\\]\\\\]/g\nconst collation: CollationDocument = { locale: 'en', strength: 2 }\n\nexport const recordingCollection = new (class extends CollectionBase<IDbRecording> {\n    readonly name = collectionName\n\n    readonly schema = RecordingSchema\n\n    readonly mediaMigration: { [id: string]: string } = {}\n\n    fromSql(sql: any): void {\n        const date = dateReg.exec(sql.Created)\n\n        const recording: IDbRecording = {\n            _id: sql.Id,\n            containerType: api.mediaType.Undefined,\n            created: (date && `${date[1]}Z`) || sql.Created,\n            genres: [],\n            languages: [],\n            links: [],\n            name: sql.Name,\n        }\n\n        if (sql.Description) {\n            recording.description = sql.Description\n        }\n\n        if (sql.RentTo) {\n            recording.rentTo = sql.RentTo\n        }\n\n        if (sql.Series) {\n            recording.series = sql.Series\n        }\n\n        const errors = validate(recording, this.schema)\n\n        if (errors) {\n            throw new Error(JSON.stringify(errors))\n        }\n\n        this.cacheMigrated(recording)\n        this.mediaMigration[recording._id] = sql.Media\n    }\n\n    async query(req: api.IRecordingQueryRequest): Promise<api.IRecordingQueryResponse> {\n        const filter: FilterQuery<IDbRecording> = {}\n\n        if (req.language) {\n            filter.languages = req.language.toString()\n        }\n\n        if (req.genres && req.genres.length > 0) {\n            filter.genres = { $all: req.genres.map(s => s.toString()) }\n        }\n\n        if (req.series && req.series.length > 0) {\n            filter.series = { $in: req.series.map(s => s.toString()) }\n        }\n\n        if (typeof req.rent === 'boolean') {\n            filter.rentTo = { $exists: req.rent }\n        }\n\n        const query = [\n            { $match: filter },\n            {\n                $graphLookup: {\n                    as: 'hierarchy',\n                    connectFromField: 'parentId',\n                    connectToField: '_id',\n                    depthField: '_depth',\n                    from: 'series',\n                    startWith: '$series',\n                },\n            },\n            { $unwind: { path: '$hierarchy', preserveNullAndEmptyArrays: true } },\n            { $sort: { 'hierarchy._depth': 1 } },\n            {\n                $group: {\n                    _id: '$_id',\n                    created: { $first: '$created' },\n                    description: { $first: '$description' },\n                    genres: { $first: '$genres' },\n                    languages: { $first: '$languages' },\n                    links: { $first: '$links' },\n                    media: { $first: '$media' },\n                    name: { $first: '$name' },\n                    rentTo: { $first: '$rentTo' },\n                    series: { $first: '$series' },\n                    sortedHierarchy: { $push: '$hierarchy' },\n                },\n            },\n            {\n                $project: {\n                    _id: 1,\n                    created: 1,\n                    description: 1,\n                    fullName: {\n                        $reduce: {\n                            in: { $concat: ['$$this.name', ' > ', '$$value'] },\n                            initialValue: '$name',\n                            input: '$sortedHierarchy',\n                        },\n                    },\n                    genres: 1,\n                    languages: 1,\n                    links: 1,\n                    media: 1,\n                    name: 1,\n                    rentTo: 1,\n                    series: 1,\n                },\n            },\n        ]\n\n        if (req.fullName) {\n            query.push({\n                $match: { fullName: { $regex: req.fullName.toString().replace(escapeReg, '\\\\$&'), $options: 'i' } },\n            })\n        }\n\n        const baseQuery = [...query]\n\n        // Für die eigentliche Ergebnisermittlung sind aller Filter aktiv.\n        query.push(<any>{\n            $facet: {\n                count: [{ $count: 'total' }],\n                genres: [{ $unwind: '$genres' }, { $group: { _id: '$genres', count: { $sum: 1 } } }],\n                view: [\n                    { $sort: { [req.sort.toString()]: req.sortOrder === 'ascending' ? +1 : -1 } },\n                    { $skip: 1 * req.firstPage * req.pageSize },\n                    { $limit: 1 * req.pageSize },\n                ],\n            },\n        })\n\n        databaseTrace('query recordings: %j', query)\n\n        const me = await this.getCollection()\n        const result = await me.aggregate<IAggregationResult>(query, { collation }).toArray()\n\n        const firstRes = result && result[0]\n        const countRes = firstRes && firstRes.count && firstRes.count[0]\n\n        // Für die Bewertung der Sprachen muss der Sprachfilter deaktiviert werden.\n        delete filter.languages\n\n        const languageInfo = await me\n            .aggregate<api.IQueryCountInfo>(\n                [...baseQuery, { $unwind: '$languages' }, { $group: { _id: '$languages', count: { $sum: 1 } } }],\n                { collation },\n            )\n            .toArray()\n\n        return {\n            correlationId: req.correlationId,\n            count: (countRes && countRes.total) || 0,\n            genres: (firstRes && firstRes.genres) || [],\n            languages: languageInfo || [],\n            total: await me.countDocuments(),\n            list: (firstRes && firstRes.view) || [],\n        }\n    }\n\n    async findOneAndReplace(recording: IDbRecording): Promise<api.IValidationError[]> {\n        const existing = await this.findOne(recording._id)\n\n        if (existing) {\n            recording = { ...recording, created: existing.created }\n        }\n\n        return super.findOneAndReplace(recording)\n    }\n\n    async inUse<TProp extends keyof IDbRecording>(property: TProp, id: string, scope: string): Promise<string> {\n        const me = await this.getCollection()\n        const count = await me.countDocuments({ [property]: typeof id === 'string' && id })\n\n        switch (count) {\n            case 0:\n                return undefined\n            case 1:\n                return `${scope} wird noch für eine Aufzeichnung verwendet`\n            default:\n                return `${scope} wird noch für ${count} Aufzeichnungen verwendet`\n        }\n    }\n})()\n"],"sourceRoot":"/home/jochenmanns/Software/git/MovieDBNode/Server/src"}